<!--memo 이 코드 분석의 목표 : 닿으면 게임이 끝나는 함수 얻기  -->
<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border:1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
</head>
<body onload="startGame()">
  <!-- ? onoload가 뭐일까? -->
<!-- memo 프로그램이 기동할때 무언가를 작동하게 하고 싶을 때 씀 -->

<script>

var myGamePiece;
var myObstacles = [];
var mySound;
var myMusic;
// <!-- ? 왜 변수를 선언만 하는 걸까? -->
// <!-- ^ 변수를 전역으로 설정하기 위해서? -->
    // <!--todo 질문-->


function startGame() {

    myGamePiece = new component(30, 30, "red", 10, 120);
    mySound = new sound("bounce.mp3");
    myMusic = new sound("gametheme.mp3");
    myMusic.play();
    myGameArea.start();
    // <!-- ^ 위에서 설정한 변수들에 지금은 무슨 의미인지 알 수 없는 함수로 값을 할당함-->
    
}
  // 함수 startGame이라는 걸 선언함 -> 
  // <!-- ^ 게임을 시작하는 함수인가봐 -->

var myGameArea = {



  // 함수 myGameArea는 객체를 가지고 있는데,
  canvas : document.createElement("canvas"),
  // canvas라는 element를 문서에서 가져오고
  start : function() {
      // start라는 객체인데 값(이 맞는 표현인지 모르겠음) 함수이고.
        this.canvas.width = 480;
        // myGameArea의 객체중 canvas의 속성중 width를 480로 잡음 (이거는 px로 안해도 되나?)
        this.canvas.height = 270;
        // myGameArea의 객체중 canvas의 속성중 height를 270로 잡음 (이거는 px로 안해도 되나?)
        this.context = this.canvas.getContext("2d");
        // myGameArea의 객체중 context를 this.canvas.getContext("2d");로 설정 
        // <!--? context라는 객체가 없는데, 이렇게 this를 쓰면 없던 객체를 추가할수도 있나?-->
        
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        // body라는 문서의 객체중 하나에  document.body.childNodes[0]의 앞에 this.canvas라는 요소 추가 
        this.frameNo = 0;
        // frameNo라는 게 내장되어있는 걸까? -> 근데 myGameArea는 내가 만든 함수잖아
        this.interval = setInterval(updateGameArea, 20);
        // interval이라는 게 내장되어있는 걸까? -> 근데 myGameArea는 내가 만든 함수잖아
        // <!--^내 생각에는 이런식으로 this를 써서 객체를 추가할 수 있는것같음-->
    },



    stop : function() {
      // stop이라는 객체로 함수가 있고
        clearInterval(this.interval);
        //clearInterval을 가지는데 myGameArea의 객체중 this.interval를 인수로 가지고 있음 
    },    

    clear : function() {
      // clear라는 요소가있는데 그거에 함수가 있음 
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        // this.context.clearRect라는 메서드에 위의 인자를 씀
        // <!--todo .clearRect에 대해서 알아보기 (내장 메서드인것 같음)-->
        // <!--* clearRect : canvas 지우기 (erasing canvas) -->
    }
}
// 변수 myGameArea를 선언 
// <!-- ^ 게임 영역을 설정하는 변수인가봐 -->





function component(width, height, color, x, y) {


    this.width = width;
    this.height = height;
    this.x = x;
    this.y = y;
    // this의 각각의 값에 
    // <!--?(여기서 this는 component인가요? 그러면 그냥 평범한 객제로 넣는 것과 차이가 뭐임?)-->
    // <!--todo 질문-->
    
    this.speedX = 0;
    this.speedY = 0;

    this.update = function() {
      ctx = myGameArea.context;
      ctx.fillStyle = color;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      //surfer의 크기와 색지정
    }
    // component 의 update는 함수 인데

    
    this.newPos = function() {
        this.x += this.speedX;
        // this.x에 this.speedX를 더함
        this.y += this.speedY;        
        // this.y에 this.speedY를 더함
    }    
    // this의 newPos은 함수 인데
    
    
    this.crashWith = function(otherobj) {
        var myleft = this.x;
        var myright = this.x + (this.width);
        var mytop = this.y;
        var mybottom = this.y + (this.height);
        // surfer의 위아래왼쪽오른쪽의 값을 변수로 선언

        
        var otherleft = otherobj.x;
        var otherright = otherobj.x + (otherobj.width);
        var othertop = otherobj.y;
        var otherbottom = otherobj.y + (otherobj.height);
        // 변수 otherdbj의 위아래왼쪽오른쪽의 값을 변수로 선언

        
        var crash = true;
        // crash라는 변수에 true라는 값을 선언할당
        
        if ((mybottom < othertop) || (mytop > otherbottom) || (myright < otherleft) || (myleft > otherright)) {
          // 만약에 
          // (mybottom < othertop)
          // (mytop > otherbottom)
          // (myright < otherleft)
          // (myleft > otherright)
          //  이중에 하나라도 만족하면 

            crash = false;
            // crash의 값을 false로 재할당
        }
        return crash;
        // 변수 crash를 밖으로 꺼냄 
        // <!--?이거 return하면 바로 전역 변수되는 건가?-->
        // <!--todo 질문-->

    }
}// 객체 this.crashWith은 변수 otherobj를 가지는 함수임
// 함수 component를 선언하는 데 매개변수 width, height,color,x,y를 가짐
// <!-- ^ surfer의 위치를 지정하는 함수 인가봐 -->






function updateGameArea() {
    var x, height, gap, minHeight, maxHeight, minGap, maxGap;
    //  지역 변수 선언 
    // <!--memo 변수를 이렇게도 선언하는 구나

    for (i = 0; i < myObstacles.length; i += 1) {
        if (myGamePiece.crashWith(myObstacles[i])) {
          // 만약에 myGamePiece.crashWith(myObstacles[i])가 있다면?
          // 왜 비교 연산자가 없지? 이런 조건문은 처음 봤네
        
            mySound.play();
            myMusic.stop();
            myGameArea.stop();
            return;
            // return만 쓰면 이 모든 걸 밖으로 빼달라는 뜻인가?
        } 
    }
    // i를 반복하는데 i가 myObstacles의 길이(배열개수)만큼 더함
    // <!--?왜 ++ 가 아니고 +=인가?-->
    // <!--* ++ :  피연산자에 1을 더합니다. 전위 연산자(++x)로 사용하면 피연산자에 1을 더한 값을 반환합니다. 
    // <!-- *      반면 후위 연산자(x++)로 사용한 경우 피연산자에 1을 더하기 전의 값을 반환합니다 -->
    // <!--* += : 오른쪽 피연산자의 값을 변수에 더한 결과를 다시 변수에 할당합니다.-->
    // <!--* =+ : -->
    // <!--memo 그러면 i가 1부터 시작하겠네 맞나?-->
    
    myGameArea.clear();
    // 함수를 선언?한건가? 용어를 모르겠다

    myGameArea.frameNo += 1;
    // myGameArea.frameNo에 1을 더하고 myGameArea.frameNo의 값에 1을 더한 값을 재할당
    
    if (myGameArea.frameNo == 1 || everyinterval(150)) {
        x = myGameArea.canvas.width;
        // 변수 x는 myGameArea.canvas.width를 할당하고 
        minHeight = 20;
        maxHeight = 200;
        // 변수에 각각의 값 할당 
        // <!--^ 최대 높이와 최소 높이를 지정했네-->
        height = Math.floor(Math.random()*(maxHeight-minHeight+1)+minHeight);
        // <!--?이 코드는 뭘까? 무언가를 랜덤으로 값을 정해주는 거 같은데?-->
        
        // <!--? Math라는 게 뭐여-->
        //<!--todo Math라는 게 뭔지 찾아보기 내장 메서드인것 같음-->
        // <!--* Math : 수학적인 상수와 함수를 위한 속성과 메서드를 가진 내장 객체입니다. 함수 객체가 아닙니다--> 
        // <!--* 다른 전역 객체와 달리 Math는 생성자가 아닙니다. Math의 모든 속성과 메서드는 정적입니다. -->
        // <!--* Math.floor() : 인수보다 작거나 같은 수 중에서 가장 큰 정수를 반환합니다.-->
        // <!--* Math.random() :0과 1 사이의 난수를 반환합니다.-->
        // <!--* 난수 : 핸덤으로 돌려서 나온수 
            // <!--memo 랜덤으로 돌려서 나온 수와 maxHeight-minHeight+1한 값이랑 곱한수에 + minHeight한 결과 보다 작거나 같은 수 중 가장 큰 정수를 반환-->
            // <!--memo 해서 그 수를 height라는 변수에 할당 
            // <!--? 그러면 왜 소괄호를 쓴거야?--> 
        minGap = 50;
        maxGap = 200;
        // 변수에 값을 할당 
        // <!-- ^ 변수 이름 보니까 최대 차이와 최소차이를 정한듯-->
        // <!-- ? 무슨 값 차이의 최대최소니?-->
        
        gap = Math.floor(Math.random()*(maxGap-minGap+1)+minGap);
         // <!--memo 랜덤으로 돌려서 나온 수와 maxGap-minGap+1를 곱한 후에 + minGap한 결과 보다 작거나 같은 수 중 가장 큰 정수를 반환-->
         // <!--memo 해서 그 수를 height라는 변수에 할당 
        
        

        myObstacles.push(new component(10, height, "green", x, 0));
        // <!--? 오 이건 진짜로 먼소리인지 하나도 모르겠다 일단 .push가 배열 메서드였던 것 같음 마지막 배열에 넣는다 였나..?-->
        myObstacles.push(new component(10, x - height - gap, "green", x, height + gap));
        // <!--? 자 정리를 하면 
            // <!-- ^ 새로운 instance 함수를 myObstalces의 배열로 넣는데 -->
            // <!-- ^ 그 instance함수는 생성자 함수가 함수 component이고  -->
            // <!-- memo  -->
            // <!-- ^  -->
    }
    // 만약 myGameArea.frameNo가 1이거나 (어떤 데이터 타입이든) everyinterval(150)이라면 

    for (i = 0; i < myObstacles.length; i += 1) {
        myObstacles[i].x -= 1;
        // myObstacles의 배열 전부의 객체중 x의 값에 -= 1 을 한다 
        // <!--todo 아직도 +=와 =+의 차이가 잘 감이 안옴 꼭 익힐것-->
        myObstacles[i].update();
    } 
    // 반복문을 돌리는 데 i에 0을 대입 ; i는 maObstacles의 길이 보다 작고 ; i+=1 해준다 
    // <!-- ? 왜 i++ 이 아니라 i+=일까? 뭐가 다르지? -->
    // <!-- ^ 내생각에는 그냥 옛날에는 저렇게 썼던게 아닐까? 뜻은 i++이나 i+=이나 똑같이 1씩 더해주라는 얘기같은데?-->

    myGamePiece.newPos();
    myGamePiece.update();
    // <!--? 왜 이 두 메서드를 함수 updateGameArea에 넣은 것일까?-->
}
// 함수 updateGameArea를 선언함
// <!-- ^ 게임 영역을 리셋하는 함수인가봐 -->









function sound(src) {
    this.sound = document.createElement("audio");
    // this.sound는 문서에 audio라는 새로운 요소를 생성한다
    this.sound.src = src;
    // this.sound.src 는 src라는 ....변수인가? 
    // <!--? 변수는 let이나 var이나 const가 있어야 선언할 수 있는거 아님?-->
    // <!-- * .sound.src : audio의 경로를 지정함(URL)-->

    this.sound.setAttribute("preload", "auto");
    // this.sound.setAttribute라는 내장 메서드의 매개 변수에 "preload"와 "auto"라는 인수 넣음
    // <!--^-->
    this.sound.setAttribute("controls", "none");
    // this.sound.setAttribute라는 내장 메서드의 매개 변수에 "controls"와 "none"라는 인수 넣음
    // <!--? 근데 이렇게 같은 메서드에 다른 인수를 넣으면 각각 다른 값이 나오나?-->

    this.sound.style.display = "none";
    //  this.sound.style.display 는 none 값을 가짐 (안보이게 할건가봐)
    

    document.body.appendChild(this.sound);
    // 문서의 body 태그의 child로 this.sound를 넣음


    this.play = function(){
        this.sound.play();
        // 함수 내용이 this.sound.play임
        // <!--* .sound.play: audio를 재생함-->
    }
    // this.play는 함수인데
    
    this.stop = function(){
        this.sound.pause();
        // <!--* .sound.pause: audio를 일시정지함-->
        // 그 함수 내용이 this.sound.pause임
    }    
} // this.stop이라는 건 함수 인데
// <!--todo .sound의 메서드 찾아보기-->
// 함수 sound를 선언하는데 매개변수가 src임
// <!-- ^ src라고 하는 걸 보니 링크를 가져오는 건가봐-->
// <!-- ^ sound라는 함수 이름을 보니 이거 소리를 제어하는 함수인가봐-->

function everyinterval(n) {
    if ((myGameArea.frameNo / n) % 1 == 0) {return true;}
    return false;
}
// 함수 everyinterval이라는 함수를 선언하는데 매개변수가 n임
// <!-- ^ canvas를 매번 다시그리고 삭제하기를 반복하는 함수인가봐 -->

function moveup() {
    myGamePiece.speedY = -1; 
}
// <!-- ^ 위로 움직이는 함수 인가봐-->

function movedown() {
    myGamePiece.speedY = 1; 
}
// <!-- ^ 아래로 움직이는 함수 인가봐-->

function moveleft() {
    myGamePiece.speedX = -1; 
}
// <!-- ^ 왼쪽로 움직이는 함수 인가봐-->

function moveright() {
    myGamePiece.speedX = 1; 
}
// <!-- ^ 오른쪽으로 움직이는 함수 인가봐-->

function clearmove() {
    myGamePiece.speedX = 0; 
    myGamePiece.speedY = 0; 
}
// <!--^ 움직임을 멈추는 함수 인가봐-->
</script>


<div style="text-align:center;width:480px;">
    <button onmousedown="moveup()" onmouseup="clearmove()" ontouchstart="moveup()">UP</button><br><br>
    <button onmousedown="moveleft()" onmouseup="clearmove()" ontouchstart="moveleft()">LEFT</button>
    <button onmousedown="moveright()" onmouseup="clearmove()" ontouchstart="moveright()">RIGHT</button><br><br>
    <button onmousedown="movedown()" onmouseup="clearmove()" ontouchstart="movedown()">DOWN</button>
    <!-- todo onmousedown이 뭔지 알아내기 -->
    <!-- * onmousedown : 마우스 버튼을 누를때 자바스트립트를 실행-->
    <!-- * onmouseup :  마우스 버튼을 때면 자바스크립트를 실현-->
    <!-- ? onmousedown과 onmouseup은 세트로 같이 다니는 건가? -->
    // <!--* 마우스를 누르고 있을때 적용된 함수와 마우스를 땠을때의 적용될 함수가 각각 다름 -->

  <!-- * ontouchstart : 핸드폰 터치시 이벤트 핸들러 인가봄 -->
  <!-- ? 그러면 이거 핸드폰에서도 적용이 가능한거여? -->
    <!-- Click the text! The mouseDown() function is triggered when the mouse button is pressed down over this paragraph, and sets the color of the text to red.
    The mouseUp() function is triggered when the mouse button is released, and sets the color of the text to green. -->
  
</div>
</body>
</html>